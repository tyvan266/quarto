{
  "hash": "482b30b465ebc765bd2cf570ce2a877f",
  "result": {
    "markdown": "---\ntitle: 'Exercises in Counting'\ndate: '2024-04-10'\ndescription: 'Application to survival analysis' \nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\ncode-annotations: true\n---\n\n\n# Introduction \n\nLife tables are common in actuarial sciences, bio-medical studies, and more generally in the field of survival analysis. They are used to track a dynamic population under observation, one where individuals may enter and leave at different times, and important for computing **at-risk** rates. In this post, we will demonstrate how to calculate simple life tables from data common in longitudinal clinical trials.\n\nSuppose we have patient data on enrollment start times (beginning of follow-up) and censoring or death times. For simplicity, instead of using R *date types*, we will represent start and end times with numeric integer. This set up is similar to our first post on *gaps and islands*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(knitr)\nlibrary(ggplot2)\n\npatient_fup_data <- \n  tibble(\n    ID             = 1:200, \n    startFollowUp  = c(sample(1:200, 200, replace = TRUE)),\n    endDeathCensor = startFollowUp + sample(30:100, 200, replace = TRUE)  \n  )\n\n\nhead(patient_fup_data, n = 10) |> kable()\n```\n\n::: {.cell-output-display}\n| ID| startFollowUp| endDeathCensor|\n|--:|-------------:|--------------:|\n|  1|           150|            203|\n|  2|           157|            201|\n|  3|            55|            143|\n|  4|            65|            147|\n|  5|           179|            272|\n|  6|            23|             96|\n|  7|           164|            255|\n|  8|           116|            209|\n|  9|            11|             74|\n| 10|           165|            217|\n:::\n:::\n\n\nRoughly, we can visualize when new patients enter and when they leave (due to death or censoring or exiting our risk set). Each segment represents a unique patient and their time segment of observation.\n\n\n::: {.cell .fig-cap-location-margin}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(patient_fup_data |> filter(ID <= 30)) +\n  geom_linerange(\n    aes(xmin = startFollowUp, xmax = endDeathCensor, y = ID)\n    , linewidth = 1) +\n  \n  theme_bw() +\n  xlab(\"Entry / Exit\") +\n  ylab(\"Patient ID\") + \n  \n  theme(\n    axis.text.x = element_text(size = 16, angle = 45),\n    strip.text = element_text(size = 18), \n    axis.title.x = element_text(size = 24),\n    axis.title.y = element_text(size = 24),\n    legend.position = 'right'\n  )\n```\n\n::: {.cell-output-display}\n![Observation time intervals by patients](post_files/figure-html/unnamed-chunk-2-1.png){width=1440}\n:::\n:::\n\n\nOur goal is to count over time the current number of patients under observation.\n\n## Joining and cross method\n\nIn this method, we will highlight the merging operators `left_join` and `cross_join` (also known as *cartesian* joins).\n\n::: callout-warning\nCartesian joins can be computationally intensive and slow!\n:::\n\nFirst, we pre-define a grid for time points of interest. Suppose we want to asses counts every 60 time units. The Cartesian join will match every row in the left table (our time point reference) to every row in the right table (our patient data). Then for each patient whose observation window intersects with our index time, we add one: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurvival_grid <- tibble(xtime = seq(0, 500, 60))\n\nsurv_grid_xpatients <- survival_grid |> cross_join(patient_fup_data)\n\nsurvival_grid_counts <- \nsurv_grid_xpatients |> \n  mutate(count = startFollowUp <= xtime & endDeathCensor >= xtime) |> \n  group_by(xtime) |> \n  summarise(count = sum(count))\n\n\nhead(survival_grid_counts) |> kable()\n```\n\n::: {.cell-output-display}\n| xtime| count|\n|-----:|-----:|\n|     0|     0|\n|    60|    58|\n|   120|    70|\n|   180|    66|\n|   240|    21|\n|   300|     0|\n:::\n:::\n\n\n\n## Map to the rescue \n\nIn this method, we do a rolling count moving through each patient. Eventually we subset on unique entry times where a change in the total population can occur. In particular, at each unique entry time when one or more new patients enroll, we add up the total number of enrollees (a simple row count works here as we cycle through the patient dataset). But we must adjust at each entry the total number lost to death or censoring up to that point. Since more than one patient may enter at the same time, the final numbers in our rolling count appears last by entry times provided we start counting in order from the first entry. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nN_under_observation <- \npatient_fup_data |> \n  arrange(startFollowUp) |> \n  \n  mutate(\n    Nenroll = row_number(), \n    Nlost   = map_dbl(startFollowUp, \\(.x) sum(endDeathCensor <= .x)), \n    N_obs   = Nenroll - Nlost \n  ) |> \n  \n  group_by(startFollowUp) |> \n  slice(n()) \n```\n:::\n\n\nFinally, we visualize the change in our patient population size over time. \n\n\n::: {.cell .fig-cap-location-margin}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(N_under_observation, aes(x = startFollowUp, y = N_obs)) + \n  geom_step(size = 1) + \n  xlab(\"Time\") + \n  ylab(\"Number under observation\") + \n  theme_bw() + \n  theme(\n    axis.text.x = element_text(size = 16, angle = 45),\n    strip.text = element_text(size = 18), \n    axis.title.x = element_text(size = 24),\n    axis.title.y = element_text(size = 24),\n    legend.position = 'right'\n  )\n```\n\n::: {.cell-output-display}\n![Population size over time](post_files/figure-html/unnamed-chunk-5-1.png){width=1440}\n:::\n:::\n",
    "supporting": [
      "post_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}